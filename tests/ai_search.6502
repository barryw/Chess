; Tests for AI Search Module (MakeMove / UnmakeMove)
; Tests the core make/unmake infrastructure needed for tree search

suites {
  suite("MakeMove Basic") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("simple-pawn-push", "White pawn e2-e4 basic move") {
      ; Initialize search
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Initial position, white pawn on e2 ($64)
      ; Make move e2-e4 (from=$64, to=$44)
      a = $64
      x = $44
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify: e2 is now empty, e4 has white pawn
      assert(peekbyte([Board88] + $64) == $30, "e2 should be empty (EMPTY_PIECE=$30)")
      assert(peekbyte([Board88] + $44) == $b1, "e4 should have white pawn ($b1)")
      assert(peekbyte([SearchDepth]) == 1, "Depth should be 1 after move")
      ; En passant should be set to e3 ($54)
      assert(peekbyte([enpassantsq]) == $54, "En passant square should be e3 ($54)")
    }

    test("simple-capture", "White knight captures black pawn") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Put white knight on e4 ($44), black pawn on d6 ($23)
      [Board88] + $44 = $b2
      [Board88] + $23 = $31

      ; Make move Nxd6 (from=$44, to=$23)
      a = $44
      x = $23
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify capture
      assert(peekbyte([Board88] + $44) == $30, "e4 should be empty")
      assert(peekbyte([Board88] + $23) == $b2, "d6 should have white knight")
      ; Check undo stack has captured piece
      assert(peekbyte([UndoStack]) == $31, "Captured piece should be black pawn ($31)")
    }

    test("non-pawn-clears-ep", "Non-pawn move clears en passant") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Set en passant square to something
      [enpassantsq] = $24

      ; Move a knight (not a pawn)
      a = $76
      x = $65
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; En passant should be cleared
      assert(peekbyte([enpassantsq]) == $ff, "En passant should be cleared after non-pawn move")
    }
  }

  suite("MakeMove Castling") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("white-kingside-castle", "O-O for white") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear f1 and g1 for castling
      [Board88] + $75 = $30
      [Board88] + $76 = $30
      ; Ensure king on e1 and rook on h1
      [Board88] + $74 = $b6
      [Board88] + $77 = $b4
      [whitekingsq] = $74
      [castlerights] = $0f

      ; Make kingside castle: e1-g1 (delta = +2)
      a = $74
      x = $76
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify king and rook positions
      assert(peekbyte([Board88] + $74) == $30, "e1 should be empty")
      assert(peekbyte([Board88] + $76) == $b6, "g1 should have white king")
      assert(peekbyte([Board88] + $77) == $30, "h1 should be empty")
      assert(peekbyte([Board88] + $75) == $b4, "f1 should have white rook")
      assert(peekbyte([whitekingsq]) == $76, "White king square should be g1")
    }

    test("white-queenside-castle", "O-O-O for white") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear b1, c1, d1 for castling
      [Board88] + $71 = $30
      [Board88] + $72 = $30
      [Board88] + $73 = $30
      ; Ensure king on e1 and rook on a1
      [Board88] + $74 = $b6
      [Board88] + $70 = $b4
      [whitekingsq] = $74
      [castlerights] = $0f

      ; Make queenside castle: e1-c1 (delta = -2)
      a = $74
      x = $72
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify positions
      assert(peekbyte([Board88] + $74) == $30, "e1 should be empty")
      assert(peekbyte([Board88] + $72) == $b6, "c1 should have white king")
      assert(peekbyte([Board88] + $70) == $30, "a1 should be empty")
      assert(peekbyte([Board88] + $73) == $b4, "d1 should have white rook")
      assert(peekbyte([whitekingsq]) == $72, "White king square should be c1")
    }

    test("black-kingside-castle", "O-O for black") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear f8 and g8
      [Board88] + $05 = $30
      [Board88] + $06 = $30
      ; Ensure black king on e8 and rook on h8
      [Board88] + $04 = $36
      [Board88] + $07 = $34
      [blackkingsq] = $04
      [castlerights] = $0f
      ; Set to black-s turn
      [SearchSide] = $00

      ; Make black kingside castle: e8-g8
      a = $04
      x = $06
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify positions
      assert(peekbyte([Board88] + $04) == $30, "e8 should be empty")
      assert(peekbyte([Board88] + $06) == $36, "g8 should have black king")
      assert(peekbyte([Board88] + $07) == $30, "h8 should be empty")
      assert(peekbyte([Board88] + $05) == $34, "f8 should have black rook")
      assert(peekbyte([blackkingsq]) == $06, "Black king square should be g8")
    }
  }

  suite("UnmakeMove Basic") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("unmake-pawn-push", "Unmake e2-e4 restores position") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Save original state
      [screenbuffer] = peekbyte([Board88] + $64)
      [screenbuffer] + 1 = peekbyte([Board88] + $44)
      [screenbuffer] + 2 = peekbyte([enpassantsq])

      ; Make move
      a = $64
      x = $44
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Unmake move
      a = $64
      x = $44
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify restored
      assert(peekbyte([Board88] + $64) == peekbyte([screenbuffer]), "e2 should be restored")
      assert(peekbyte([Board88] + $44) == peekbyte([screenbuffer] + 1), "e4 should be restored")
      assert(peekbyte([enpassantsq]) == peekbyte([screenbuffer] + 2), "en passant should be restored")
      assert(peekbyte([SearchDepth]) == 0, "Depth should be 0 after unmake")
    }

    test("unmake-capture", "Unmake capture restores captured piece") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: White knight on e4, black pawn on d6
      [Board88] + $44 = $b2
      [Board88] + $23 = $31

      ; Make capture
      a = $44
      x = $23
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Unmake capture
      a = $44
      x = $23
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify both pieces restored
      assert(peekbyte([Board88] + $44) == $b2, "e4 should have white knight again")
      assert(peekbyte([Board88] + $23) == $31, "d6 should have black pawn again")
    }
  }

  suite("UnmakeMove Castling") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("unmake-white-kingside-castle", "Unmake O-O restores king and rook") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup for castling
      [Board88] + $75 = $30
      [Board88] + $76 = $30
      [Board88] + $74 = $b6
      [Board88] + $77 = $b4
      [whitekingsq] = $74
      [castlerights] = $0f

      ; Make castle
      a = $74
      x = $76
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Unmake castle
      a = $74
      x = $76
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify restored
      assert(peekbyte([Board88] + $74) == $b6, "e1 should have king")
      assert(peekbyte([Board88] + $75) == $30, "f1 should be empty")
      assert(peekbyte([Board88] + $76) == $30, "g1 should be empty")
      assert(peekbyte([Board88] + $77) == $b4, "h1 should have rook")
      assert(peekbyte([whitekingsq]) == $74, "King square should be e1")
      assert(peekbyte([castlerights]) == $0f, "Castling rights should be restored")
    }
  }

  suite("MakeMove En Passant") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("white-en-passant-capture", "White pawn captures black pawn en passant") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: White pawn on e5 ($34), black pawn on d5 ($33), EP square d6 ($23)
      memfill([Board88], 128, $30)
      [Board88] + $34 = $b1
      [Board88] + $33 = $31
      [enpassantsq] = $23
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; White pawn captures en passant: e5xd6
      a = $34
      x = $23
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify: white pawn on d6, d5 empty (captured pawn removed)
      assert(peekbyte([Board88] + $34) == $30, "e5 should be empty")
      assert(peekbyte([Board88] + $23) == $b1, "d6 should have white pawn")
      assert(peekbyte([Board88] + $33) == $30, "d5 should be empty (captured pawn removed)")
    }

    test("unmake-en-passant", "Unmake restores both pawns") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup
      memfill([Board88], 128, $30)
      [Board88] + $34 = $b1
      [Board88] + $33 = $31
      [enpassantsq] = $23
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; Make en passant
      a = $34
      x = $23
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Unmake
      a = $34
      x = $23
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Verify both pawns restored
      assert(peekbyte([Board88] + $34) == $b1, "e5 should have white pawn")
      assert(peekbyte([Board88] + $33) == $31, "d5 should have black pawn")
      assert(peekbyte([Board88] + $23) == $30, "d6 should be empty")
      assert(peekbyte([enpassantsq]) == $23, "EP square should be restored")
    }
  }

  suite("Search Depth Stack") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("multiple-make-unmake", "Make 3 moves then unmake all") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Move 1: e2-e4
      a = $64
      x = $44
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchDepth]) == 1, "Depth should be 1")

      ; Move 2: d7-d5
      a = $13
      x = $33
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchDepth]) == 2, "Depth should be 2")

      ; Move 3: Nf3
      a = $76
      x = $55
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchDepth]) == 3, "Depth should be 3")

      ; Unmake all in reverse order
      a = $76
      x = $55
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchDepth]) == 2, "Depth should be 2 after first unmake")

      a = $13
      x = $33
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchDepth]) == 1, "Depth should be 1 after second unmake")

      a = $64
      x = $44
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchDepth]) == 0, "Depth should be 0 after third unmake")

      ; Verify board restored to initial position
      assert(peekbyte([Board88] + $64) == $b1, "e2 should have white pawn")
      assert(peekbyte([Board88] + $13) == $31, "d7 should have black pawn")
      assert(peekbyte([Board88] + $76) == $b2, "g1 should have white knight")
    }

    test("side-to-move-toggles", "SearchSide alternates with each move") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Initial: white to move
      assert(peekbyte([SearchSide]) == $80, "Should start as white ($80)")

      ; After white move
      a = $64
      x = $44
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchSide]) == $00, "Should be black turn ($00)")

      ; After black move
      a = $13
      x = $33
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchSide]) == $80, "Should be white turn ($80)")

      ; Unmake black move
      a = $13
      x = $33
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchSide]) == $00, "Should be black turn after unmake")

      ; Unmake white move
      a = $64
      x = $44
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([SearchSide]) == $80, "Should be white turn after unmake")
    }
  }

  suite("Rook Move Updates Castling") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("a1-rook-move-loses-WQ", "Moving a1 rook loses white queenside castling") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      [castlerights] = $0f

      ; Move rook from a1 to a2
      a = $70
      x = $60
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Should lose white queenside (bit 1) but keep others
      assert(peekbyte([castlerights]) == $0d, "Should lose WQ, have WK+BK+BQ ($0d)")
    }

    test("h1-rook-move-loses-WK", "Moving h1 rook loses white kingside castling") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      [castlerights] = $0f

      a = $77
      x = $67
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([castlerights]) == $0e, "Should lose WK, have WQ+BK+BQ ($0e)")
    }

    test("castling-rights-restored-on-unmake", "Unmake restores castling rights") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      [castlerights] = $0f

      ; Move a1 rook
      a = $70
      x = $60
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Unmake
      a = $70
      x = $60
      jsr([UnmakeMove], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([castlerights]) == $0f, "Castling rights should be fully restored")
    }
  }

  suite("Legal Move Filtering") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("initial-position-legal", "Initial position has 20 legal moves for white") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Generate legal moves for white
      jsr([GenerateLegalMoves], stop_on_rts = true, fail_on_brk = true)

      ; Initial position: 16 pawn moves (8x1 + 8x2) + 4 knight moves = 20
      assert(a == 20, "Initial position should have 20 legal moves for white")
    }

    test("filter-removes-illegal", "Filter removes moves that leave king in check") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: King on e1 ($74), enemy rook on e8 ($04)
      ; King is in check from rook - only legal moves are escapes
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $04 = $34    ; Black rook on e8
      [whitekingsq] = $74
      [blackkingsq] = $ff      ; No black king (test position)

      jsr([GenerateLegalMoves], stop_on_rts = true, fail_on_brk = true)

      ; King can move to d1, d2, f1, f2 (4 moves)
      ; Cannot move to e2 (still in check from rook)
      ; Pseudo-legal would generate 8 king moves, legal should be fewer
      assert(a < 8, "Should filter out some illegal king moves")
      assert(a >= 4, "Should have at least 4 escape squares")
    }

    test("pinned-piece-limited", "Pinned piece has limited legal moves") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: King on e1 ($74), own bishop on e3 ($54), enemy rook on e8 ($04)
      ; Bishop is pinned to king - cannot move without exposing king
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $54 = $b3    ; White bishop on e3 (pinned)
      [Board88] + $04 = $34    ; Black rook on e8
      [whitekingsq] = $74
      [blackkingsq] = $ff
      [castlerights] = 0       ; No castling
      [enpassantsq] = $ff      ; No en passant

      jsr([GenerateLegalMoves], stop_on_rts = true, fail_on_brk = true)

      ; Legal moves: King can move to d1, d2, e2, f1, f2 (5 squares)
      ; Bishop on e3 still blocks rook after any king move, so all 5 are safe
      ; Bishop cannot move at all (pinned - would expose king)
      ; Expect exactly 5 legal moves (all king moves)
      assert(a == 5, "Should have exactly 5 legal king moves")
    }
  }

  suite("IsSearchKingInCheck") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("detects-check-after-move", "Detects king in check after making move") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: King on e1, bishop on e4 blocking rook on e8
      ; Moving bishop diagonally exposes king to rook
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b3    ; White bishop on e4 (blocking)
      [Board88] + $04 = $34    ; Black rook on e8
      [whitekingsq] = $74
      [blackkingsq] = $ff

      ; Move bishop e4-d3 (diagonal move, exposes king)
      a = $44
      x = $53
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      ; Check if white king is in check (white just moved)
      jsr([IsSearchKingInCheck], stop_on_rts = true, fail_on_brk = true)

      ; Should detect check (carry set)
      assert(c == 1, "Should detect that white king is now in check")
    }

    test("no-check-safe-move", "Does not detect check for safe move") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: King on e1, pawn on a2 (not blocking anything)
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $60 = $b1    ; White pawn on a2
      [whitekingsq] = $74
      [blackkingsq] = $ff

      ; Move pawn a2-a4 (safe move)
      a = $60
      x = $40
      jsr([MakeMove], stop_on_rts = true, fail_on_brk = true)

      jsr([IsSearchKingInCheck], stop_on_rts = true, fail_on_brk = true)

      ; Should NOT detect check (carry clear)
      assert(c == 0, "Should not detect check for safe move")
    }
  }

  suite("Evaluate Function") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("equal-material-returns-zero", "Equal material returns score near zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Initial position has equal material
      ; Evaluate should return 0 (or close to it)
      jsr([Evaluate], stop_on_rts = true, fail_on_brk = true)

      ; Score should be 0 for equal material
      assert(a == 0, "Equal material should evaluate to 0")
    }

    test("white-advantage-positive", "White up material returns positive") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: White king + queen vs black king only
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $73 = $b5    ; White queen on d1
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      jsr([Evaluate], stop_on_rts = true, fail_on_brk = true)

      ; White up a queen = +90 raw, should be positive for white
      assert(a > 0, "White up material should be positive")
    }

    test("black-advantage-negative-for-white", "Black up material returns negative for white") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Black king + queen vs white king only
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $04 = $36    ; Black king on e8
      [Board88] + $03 = $35    ; Black queen on d8
      [whitekingsq] = $74
      [blackkingsq] = $04

      jsr([Evaluate], stop_on_rts = true, fail_on_brk = true)

      ; Black up a queen = -90 raw, should be negative for white
      ; Note: A is signed byte, < $80 means negative in signed comparison
      ; But assert compares unsigned, so check a >= $80 for negative
      assert(a >= $80, "White down material should be negative (high bit set)")
    }
  }

  suite("Negamax Search") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("depth-0-returns-eval", "Depth 0 just returns evaluation") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Equal material position
      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 0                     ; Depth 0
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; Should return eval score (0 for equal material)
      assert(a == 0, "Depth 0 should return evaluation")
    }

    test("mate-position-no-moves", "After Rh8#, black has no legal moves") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Position AFTER Rh8# - rook on h8, can't be captured
      ; Black king on a8, White rook on h8 (giving check along rank 8)
      ; White king on b6 (controlling a7 and b7 escape squares)
      memfill([Board88], 128, $30)
      [Board88] + $00 = $36    ; Black king on a8
      [Board88] + $07 = $b4    ; White rook on h8 (just moved, gives check)
      [Board88] + $21 = $b6    ; White king on b6
      [whitekingsq] = $21
      [blackkingsq] = $00

      ; Switch to black's turn
      [SearchSide] = $00

      jsr([GenerateLegalMoves], stop_on_rts = true, fail_on_brk = true)

      ; Black should have 0 legal moves (checkmate):
      ; - b8 attacked by rook on h8
      ; - b7 attacked by king on b6
      ; - a7 attacked by king on b6
      assert(a == 0, "Black should have 0 legal moves (checkmate)")
    }

    test("finds-obvious-mate", "Finds mate in 1") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Rook mate - Black king on a8, White rook on h2, White king on b6
      ; Rh8# is checkmate (rook gives check, king blocks escape squares a7/b7)
      memfill([Board88], 128, $30)
      [Board88] + $00 = $36    ; Black king on a8
      [Board88] + $67 = $b4    ; White rook on h2
      [Board88] + $21 = $b6    ; White king on b6
      [whitekingsq] = $21
      [blackkingsq] = $00

      ; Depth 2 needed: depth 1 = our move, depth 0 = opponent's response (no moves = mate)
      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 2
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; Score should be high (near mate score)
      ; Mate score is +120, returned score should be positive
      assert(a > 100, "Should find mate in 1 with high score")
    }

    test("checkmate-has-no-legal-moves", "Checkmated position has no legal moves") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Classic back-rank mate with pawns blocking escape
      ; White king on g1, white pawns on f2/g2/h2, black rook on e1
      memfill([Board88], 128, $30)
      [Board88] + $76 = $b6    ; White king on g1
      [Board88] + $65 = $b1    ; White pawn on f2
      [Board88] + $66 = $b1    ; White pawn on g2
      [Board88] + $67 = $b1    ; White pawn on h2
      [Board88] + $74 = $34    ; Black rook on e1 (delivers check)
      [Board88] + $04 = $36    ; Black king on e8 (far away)
      [whitekingsq] = $76
      [blackkingsq] = $04

      ; First verify we have no legal moves
      jsr([GenerateLegalMoves], stop_on_rts = true, fail_on_brk = true)
      assert(a == 0, "Checkmate position should have 0 legal moves")
    }

    test("checkmate-returns-negative", "Checkmated position returns negative score") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: Classic back-rank mate with pawns blocking escape
      ; White king on g1, white pawns on f2/g2/h2, black rook on e1
      memfill([Board88], 128, $30)
      [Board88] + $76 = $b6    ; White king on g1
      [Board88] + $65 = $b1    ; White pawn on f2
      [Board88] + $66 = $b1    ; White pawn on g2
      [Board88] + $67 = $b1    ; White pawn on h2
      [Board88] + $74 = $34    ; Black rook on e1 (delivers check)
      [Board88] + $04 = $36    ; Black king on e8 (far away)
      [whitekingsq] = $76
      [blackkingsq] = $04

      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 1                     ; Depth 1
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; Score should be -120 (MATE_SCORE negated)
      assert(a == $88, "Checkmate should return -120 ($88)")
    }
  }

  suite("FindBestMove") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("depth1-saves-best", "Depth 1 search saves a best move") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear BestMove first
      [BestMoveFrom] = $ff
      [BestMoveTo] = $ff

      ; Simple position: King and pawn vs lone king
      ; White should have legal moves (any move is "best" at depth 1)
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $64 = $b1    ; White pawn on e2
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 1                     ; Depth 1
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; BestMove should be set (not still $ff)
      assert(peekbyte([BestMoveFrom]) != $ff, "BestMoveFrom should be set")
      assert(peekbyte([BestMoveTo]) != $ff, "BestMoveTo should be set")
    }

    test("depth2-saves-best", "Depth 2 search saves a best move") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear BestMove first
      [BestMoveFrom] = $ff
      [BestMoveTo] = $ff

      ; Simple position: King and pawn vs lone king
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $64 = $b1    ; White pawn on e2
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 2                     ; Depth 2
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; BestMove should be set (not still $ff)
      assert(peekbyte([BestMoveFrom]) != $ff, "BestMoveFrom should be set at depth 2")
      assert(peekbyte([BestMoveTo]) != $ff, "BestMoveTo should be set at depth 2")
    }

    test("capture-position-move-gen", "Capture position generates moves correctly") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: White knight on e4, black queen on d6, white king on e1, black king on e8
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b2    ; White knight on e4
      [Board88] + $23 = $35    ; Black queen on d6
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      jsr([GenerateLegalMoves], stop_on_rts = true, fail_on_brk = true)

      ; Should have moves: knight has ~8, king has ~5, total ~13
      assert(a > 10, "Should have more than 10 legal moves")
      assert(peekbyte([MoveCount]) > 10, "MoveCount should be > 10")
    }

    test("capture-position-eval", "Capture position evaluates correctly") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Setup: White knight on e4, black queen on d6, white king on e1, black king on e8
      ; White is down a queen (30 vs 90), so eval should be negative for white
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b2    ; White knight on e4
      [Board88] + $23 = $35    ; Black queen on d6
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      jsr([Evaluate], stop_on_rts = true, fail_on_brk = true)

      ; White has knight (30), black has queen (90)
      ; Score should be negative for white (approx -60)
      ; A >= $80 means negative in signed representation
      assert(a >= $80, "White down material should be negative")
    }

    test("knight-vs-king-depth1", "Knight+King vs lone King at depth 1") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear BestMove first
      [BestMoveFrom] = $ff
      [BestMoveTo] = $ff

      ; Setup: White knight on e4, white king on e1, black king on e8 (no queen)
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b2    ; White knight on e4
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 1                     ; Depth 1 only
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; BestMove should be set
      assert(peekbyte([BestMoveFrom]) != $ff, "BestMoveFrom should be set at depth 1")
      assert(peekbyte([BestMoveTo]) != $ff, "BestMoveTo should be set at depth 1")
    }

    test("capture-position-depth1", "Capture position works at depth 1") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear BestMove first
      [BestMoveFrom] = $ff
      [BestMoveTo] = $ff

      ; Setup: White knight on e4, black queen on d6, white king on e1, black king on e8
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b2    ; White knight on e4
      [Board88] + $23 = $35    ; Black queen on d6
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; Verify initial state
      assert(peekbyte([SearchDepth]) == 0, "SearchDepth should be 0 before Negamax")
      assert(peekbyte([SearchSide]) == $80, "SearchSide should be WHITE before Negamax")

      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 1                     ; Depth 1 only
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; Check state after Negamax
      assert(peekbyte([SearchDepth]) == 0, "SearchDepth should be 0 after Negamax")
      assert(peekbyte([SearchSide]) == $80, "SearchSide should be WHITE after Negamax")

      ; Check if NegamaxState was used (move count should be stored)
      assert(peekbyte([NegamaxState]) > 0, "NegamaxState[0] (move count) should be > 0")

      ; BestMove should be set
      assert(peekbyte([BestMoveFrom]) != $ff, "BestMoveFrom should be set at depth 1")
      assert(peekbyte([BestMoveTo]) != $ff, "BestMoveTo should be set at depth 1")
    }

    test("capture-position-via-negamax", "Capture position works via direct Negamax call") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      jsr([InitSearch], stop_on_rts = true, fail_on_brk = true)

      ; Clear BestMove first
      [BestMoveFrom] = $ff
      [BestMoveTo] = $ff

      ; Setup: White knight on e4, black queen on d6, white king on e1, black king on e8
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b2    ; White knight on e4
      [Board88] + $23 = $35    ; Black queen on d6
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      ; Set up alpha-beta window
      $e8 = $80                 ; alpha = -128
      $e9 = $7f                 ; beta = +127
      a = 2
      jsr([Negamax], stop_on_rts = true, fail_on_brk = true)

      ; BestMove should be set
      assert(peekbyte([BestMoveFrom]) != $ff, "BestMoveFrom should be set")
      assert(peekbyte([BestMoveTo]) != $ff, "BestMoveTo should be set")
      ; Best move should be Nxd6 (e4 to d6, $44 to $23)
      assert(peekbyte([BestMoveFrom]) == $44, "Best move from should be e4 ($44)")
      assert(peekbyte([BestMoveTo]) == $23, "Best move to should be d6 ($23)")
    }

    test("finds-winning-capture", "Finds obvious winning capture via FindBestMove") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      [difficulty] = 0          ; Easy (depth 2)

      ; Clear BestMove first
      [BestMoveFrom] = $ff
      [BestMoveTo] = $ff

      ; Setup: White knight on e4, black queen on d6, white king on e1, black king on e8
      ; Nxd6 captures the queen - obvious best move
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $44 = $b2    ; White knight on e4
      [Board88] + $23 = $35    ; Black queen on d6
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      jsr([FindBestMove], stop_on_rts = true, fail_on_brk = true)

      ; Best move should be Nxd6 (e4 to d6, $44 to $23)
      assert(peekbyte([BestMoveFrom]) == $44, "Best move from should be e4 ($44)")
      assert(peekbyte([BestMoveTo]) == $23, "Best move to should be d6 ($23)")
    }

    test("fallback-initialization", "FindBestMove initializes to first legal move as fallback") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      [currentplayer] = 1       ; White to move
      [difficulty] = 1          ; Easy (depth 2)

      ; Set BestMove to $00 (the bug case - uninitialized from previous search)
      [BestMoveFrom] = $00
      [BestMoveTo] = $00

      ; Simple position: White king and rook, black king
      ; White should have many legal moves
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6    ; White king on e1
      [Board88] + $77 = $b4    ; White rook on h1
      [Board88] + $04 = $36    ; Black king on e8
      [whitekingsq] = $74
      [blackkingsq] = $04

      jsr([FindBestMove], stop_on_rts = true, fail_on_brk = true)

      ; BestMove should NOT be $00 (the original from a8 which is empty)
      ; It should be a valid move for white
      assert(peekbyte([BestMoveFrom]) != $00, "BestMoveFrom should not be $00 (uninitialized)")
      assert(peekbyte([BestMoveTo]) != $00, "BestMoveTo should not be $00 (uninitialized)")
    }

  }
}
