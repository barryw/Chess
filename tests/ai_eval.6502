; Material Evaluation Unit Tests
; Tests basic piece value counting and material imbalance detection

suites {
  suite("Material Values") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("eval-initial-position", "Initial position has equal material") {
      ; Test with the board's initial state (standard chess position)
      ; Each side has: 8 pawns(80) + 2 knights(64) + 2 bishops(66) + 2 rooks(100) + 1 queen(90) = 400
      ; Equal material means score = 0
      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Initial position low byte should be zero")
      assert(peekbyte([EvalScore] + $01) == $00, "Initial position high byte should be zero")
    }

    test("eval-empty-board", "Empty board evaluates to zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Empty board should have zero score")
      assert(peekbyte([EvalScore] + $01) == $00, "Empty board high byte should be zero")
    }

    test("eval-equal-pawns", "Equal pawns evaluate to zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)
      [Board88] + $64 = $b1  ; WHITE_PAWN at e3
      [Board88] + $34 = $31  ; BLACK_PAWN at e5

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      ; Equal material - score should be 0
      assert(peekbyte([EvalScore]) == $00, "Equal pawns should have zero score")
    }

    test("eval-equal-knights", "Equal knights evaluate to zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)
      [Board88] + $44 = $b2  ; WHITE_KNIGHT at e4
      [Board88] + $24 = $32  ; BLACK_KNIGHT at e6

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Equal knights should have zero score")
    }

    test("eval-equal-bishops", "Equal bishops evaluate to zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)
      [Board88] + $44 = $b3  ; WHITE_BISHOP at e4
      [Board88] + $24 = $33  ; BLACK_BISHOP at e6

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Equal bishops should have zero score")
    }

    test("eval-equal-rooks", "Equal rooks evaluate to zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)
      [Board88] + $44 = $b4  ; WHITE_ROOK at e4
      [Board88] + $24 = $34  ; BLACK_ROOK at e6

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Equal rooks should have zero score")
    }

    test("eval-equal-queens", "Equal queens evaluate to zero") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)
      [Board88] + $44 = $b5  ; WHITE_QUEEN at e4
      [Board88] + $24 = $35  ; BLACK_QUEEN at e6

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Equal queens should have zero score")
    }

    test("eval-kings-not-counted", "Kings have no material value") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)
      [Board88] + $74 = $b6  ; WHITE_KING at e1
      [Board88] + $04 = $36  ; BLACK_KING at e8

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      assert(peekbyte([EvalScore]) == $00, "Kings should not affect score")
    }
  }

  suite("Board Changes Affect Evaluation") {
    symbols("/code/main.sym")
    load("/code/main.prg", strip_header = true)

    test("eval-board-modification-detected", "Evaluation processes board changes") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      ; Empty board - should evaluate to 0
      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([EvalScore]) == $00, "Empty board has zero score")

      ; Add a white pawn - white should have material advantage
      [Board88] + $64 = $b1  ; WHITE_PAWN at e2

      ; Evaluation should now show white ahead (positive score)
      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)
      assert(peekbyte([EvalScore]) != $00, "Adding piece changes score")
    }

    test("eval-white-pawn-advantage", "White pawn gives positive score") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      ; Add just one white pawn (value = 10 centipawns)
      [Board88] + $64 = $b1  ; WHITE_PAWN at e2

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      ; Score should be 10 ($0A) for one pawn
      assert(peekbyte([EvalScore]) == $0a, "White pawn worth 10 centipawns")
      assert(peekbyte([EvalScore] + $01) == $00, "High byte should be zero for small value")
    }

    test("eval-black-pawn-advantage", "Black pawn gives negative score") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      ; Add just one black pawn
      [Board88] + $14 = $31  ; BLACK_PAWN at e7

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      ; Score should be -10 (two's complement: $FFF6)
      ; Low byte = $F6, high byte = $FF
      assert(peekbyte([EvalScore]) == $f6, "Black pawn gives negative score (low byte)")
      assert(peekbyte([EvalScore] + $01) == $ff, "Black advantage shows in high byte")
    }

    test("eval-knight-value", "Knight worth 32 centipawns") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      ; Add one white knight
      [Board88] + $44 = $b2  ; WHITE_KNIGHT at e4

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      ; Knight value = 32 ($20)
      assert(peekbyte([EvalScore]) == $20, "White knight worth 32 centipawns")
    }

    test("eval-rook-value", "Rook worth 50 centipawns") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      ; Add one white rook
      [Board88] + $44 = $b4  ; WHITE_ROOK at e4

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      ; Rook value = 50 ($32)
      assert(peekbyte([EvalScore]) == $32, "White rook worth 50 centipawns")
    }

    test("eval-queen-value", "Queen worth 90 centipawns") {
      jsr([InitZobristTables], stop_on_rts = true, fail_on_brk = true)
      memfill([Board88], 128, $30)

      ; Add one white queen
      [Board88] + $44 = $b5  ; WHITE_QUEEN at e4

      jsr([EvaluateMaterial], stop_on_rts = true, fail_on_brk = true)

      ; Queen value = 90 ($5A)
      assert(peekbyte([EvalScore]) == $5a, "White queen worth 90 centipawns")
    }
  }
}
